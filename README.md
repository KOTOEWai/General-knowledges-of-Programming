
## 📑 Table of Contents

- [Vite](#Vite)
- [Bundler](#Bundler)
- [Call Stack နှင့် Memory Heap အလုပ်လုပ်ပုံ](#Call-Stack-နှင့်-Memory-Heap-အလုပ်လုပ်ပုံ)
- [Abstract Syntax Tree (AST)](#Abstract-Syntax-Tree-(AST))
- [Interpreter နဲ့ Compiler](#interpreter-နဲ့-compiler)
- [UML](#UML)
- [Use Case Diagram](#use-case-diagram)

## Vite

```
Vite (ပြင်သစ်ဘာသာစကားဖြင့် "အမြန်" ဟု အဓိပ္ပာယ်ရပြီး "veet" ဟု အသံထွက်သည်) သည်
 ခေတ်သစ် Web Development လောကတွင် အသုံးပြုနေကြသည့်
အလွန်မြန်ဆန်သော Build Tool တစ်ခု ဖြစ်ပါသည်။

အရင်က React project တွေမှာ အသုံးများခဲ့တဲ့ Create React App (CRA) နဲ့ Webpack 
တို့နေရာမှာ အခုဆိုရင် Vite က အစားထိုးဝင်ရောက်လာပြီ ဖြစ်ပါတယ်။

Vite က ဘာကြောင့် ပိုကောင်းတာလဲ?

Vite ကို အဓိက အချက် (၂) ချက်ကြောင့် လူကြိုက်များကြပါတယ်-

1. အလွန်မြန်သော Development Server: သင် code တစ်ခုခုပြင်လိုက်တိုင်း Browser မှာ
 ချက်ချင်းပြောင်းလဲသွားအောင် လုပ်ဆောင်ပေးတဲ့နေရာမှာ
 Webpack ထက် အဆပေါင်းများစွာ ပိုမြန်ပါတယ်။ ဒါကို Hot Module Replacement (HMR) လို့ ခေါ်ပါတယ်။

2. မြန်ဆန်သော Build Time: Project ကို အချောသတ် (Production) ထုတ်တဲ့အခါမှာလည်း
 ခေတ်မီတဲ့ Rollup bundler ကို အသုံးပြုထားလို့ 
file size သေးသေးနဲ့ မြန်မြန်ဆန်ဆန် ထွက်လာစေပါတယ်။

Vite ရဲ့ အဓိက ထူးခြားချက်များ

Instant Server Start: Project ကို စတင် run တဲ့အခါ စက္ကန့်ပိုင်းအတွင်း တက်လာပါတယ်။

TypeScript Ready: TypeScript အတွက် ဘာမှထပ်ပြင်စရာမလိုဘဲ အသင့်အသုံးပြုနိုင်ပါတယ်။

Optimized Build: သင့်ရဲ့ Website ကို အမြန်ဆုံး load ဖြစ်အောင် code တွေကို အလိုအလျောက် 
ကျစ်လျစ်အောင် လုပ်ပေးပါတယ်။

Plugin Ecosystem: လိုအပ်တဲ့ features တွေကို plugin တွေအဖြစ် အလွယ်တကူ ထည့်သွင်းနိုင်ပါတယ်။

မှတ်ချက်: အခုနောက်ပိုင်း React ရော၊ Vue ရော၊ အခြား Frontend Framework တွေမှာပါ Vite ကိုပဲ
 Standard အနေနဲ့ သုံးဖို့ အကြံပြုထားကြပါတယ်။
```


## Bundler
```
Bundler ဆိုတာ သင့်ရဲ့ Web Project မှာရှိတဲ့ ရာနဲ့ချီတဲ့ JavaScript file တွေ၊ CSS တွေနဲ့
ပုံ (Images) တွေကို
စုစည်းပြီး Browser က ဖတ်လို့ရမယ့် File အနည်းငယ် (ဥပမာ- bundle.js) ဖြစ်အောင် ပေါင်းစည်းပေးတဲ့ 
ကိရိယာ (Tool) တစ်ခုဖြစ်ပါတယ်။

* လွယ်လွယ်ပြောရရင်တော့ ဟင်းချက်တဲ့အခါ လိုအပ်တဲ့ ပါဝင်ပစ္စည်းတွေကို အိတ်တစ်အိတ်ထဲ စနစ်တကျ 
ထည့်ပေးလိုက်သလိုပါပဲ။

Bundler က ဘာကြောင့် လိုအပ်တာလဲ?

 ၁။ File တွေ အရမ်းများခြင်း: Developer တွေက အလုပ်လုပ်ရလွယ်အောင် code တွေကို
  file သေးသေးလေးတွေ အများကြီး ခွဲရေးကြပါတယ်။
  ဒါပေမဲ့ Browser က အဲဒီ file ပေါင်းများစွာကို တစ်ခုချင်းစီ လှမ်းခေါ်နေရင် Website က
  အရမ်းနှေးသွားပါလိမ့်မယ်။

 ၂။ Dependency Management: File တစ်ခုနဲ့တစ်ခု ချိတ်ဆက်နေမှု (ဥပမာ- A က B ကို အားကိုးနေတာမျိုး)
  ကို Bundler က စနစ်တကျ စီစဉ်ပေးပါတယ်။
 
 ၃။ Asset Optimization: Code တွေကို ကျစ်လျစ်အောင်လုပ်တာ (Minification) နဲ့ မလိုအပ်တဲ့ 
 code တွေကို ဖယ်ထုတ်တာ (Tree Shaking) တွေကို လုပ်ဆောင်ပေးပါတယ်။

Bundler တစ်ခု ဘယ်လိုအလုပ်လုပ်သလဲ?

Bundler က သင့်ရဲ့ Project ထဲက အဓိက file (Entry Point) ကို အရင်ကြည့်ပါတယ်။ 
အဲဒီကမှတစ်ဆင့် ချိတ်ဆက်နေတဲ့ အခြား file တွေကို လိုက်ရှာပြီး "Graph" တစ်ခု ဆောက်ပါတယ်။ 
နောက်ဆုံးမှာတော့ Browser နားလည်တဲ့ static file တွေအဖြစ် ပြောင်းလဲပေးလိုက်ပါတယ်။

သင်က Vite ကို သုံးနေတယ်ဆိုရင် Bundler အကြောင်းကို ခေါင်းထဲအများကြီး ထည့်စရာမလိုဘဲ
 သူက အနောက်ကနေ အကုန်လုံးကို အလိုအလျောက် အကောင်းဆုံးဖြစ်အောင် စီစဉ်ပေးသွားမှာပါ။
```
## Call Stack နှင့် Memory Heap အလုပ်လုပ်ပုံ

```
Reference types (Objects, Arrays) တွေအတွက် JavaScript က အခုလို ခွဲဝေလိုက်ပါတယ်-

Memory Heap
    တကယ့် Data အကြီးစားတွေ (ဥပမာ- { name: "Aung Aung", age: 25 }) ကို
ဒီနေရာမှာ သိမ်းပါတယ်။ ဒီနေရာက ကျယ်ဝန်းပြီး ရှုပ်ထွေးတဲ့ structure တွေကို သိမ်းဖို့ပါ။

Call Stack
    ဒီနေရာမှာတော့ variable နာမည်နဲ့ အဲဒီ data ရှိရာနေရာကို ညွှန်ပြတဲ့ 
Memory Address (Reference) ကိုပဲ သိမ်းပါတယ်။


ဘယ်လို အလုပ်လုပ်သလဲ (Step-by-Step)

ဥပမာ- let user = { name: "Aung Aung" }; လို့ ရေးလိုက်ရင်:

အဆင့် (၁): JavaScript က Heap ထဲမှာ နေရာလွတ်တစ်ခုရှာပြီး 
{ name: "Aung Aung" } ဆိုတဲ့ object ကို သိမ်းလိုက်ပါတယ်။ အဲဒီနေရာရဲ့ လိပ်စာက ဥပမာ 0x123 ဆိုပါစို့။

အဆင့် (၂): Call Stack ထဲမှာ user ဆိုတဲ့ variable name ကို သတ်မှတ်ပါတယ်။

အဆင့် (၃): Stack ထဲက user ရဲ့ value နေရာမှာ အစောက လိပ်စာ 0x123 ကို သိမ်းလိုက်ပါတယ်။

မှတ်ချက်: Stack ထဲမှာ object ကြီးတစ်ခုလုံး သိမ်းဖို့က နေရာမလောက်နိုင်သလို၊ ရှုပ်ထွေးနိုင်တာကြောင့် 
လိပ်စာကတ်လေး (Reference) ကိုပဲ Stack ထဲ ထည့်ထားတာ ဖြစ်ပါတယ်။


Location,        Identifier (Variable)            Value (Content)

Call Stack,          user,                           Ref: 0x123 (Address)
Memory Heap          0x123,                         { name: ""Aung Aung"" }


ဒါကြောင့် ဘာဖြစ်သလဲ?

သင်က let admin = user; လို့ ထပ်ရေးလိုက်ရင် JavaScript က Stack ထဲမှာ variable အသစ်တစ်ခု ဆောက်ပါတယ်။ 
ဒါပေမဲ့ သူက value အသစ်ကို copy ကူးတာ မဟုတ်ဘဲ 0x123 ဆိုတဲ့ လိပ်စာကိုပဲ copy ကူးလိုက်တာပါ။

ရလဒ်ကတော့ user ရော admin ရောက Heap ထဲက object တစ်ခုတည်းကိုပဲ ပိုင်ဆိုင်သွားတာ ဖြစ်ပါတယ်။

------------------------------------------------------------------------------------------------------------------

Primitive types (Number, String, Boolean, Null, Undefined, Symbol, BigInt)
တွေကတော့ Reference types တွေနဲ့ လုံးဝဆန့်ကျင်ဘက် အလုပ်လုပ်ပါတယ်။ သူတို့က memory ထဲမှာ
ပိုပြီးရိုးရှင်းသလို၊ ပိုလည်းမြန်ဆန်ပါတယ်။

Primitive types တွေ အလုပ်လုပ်ပုံကို အချက် (၃) ချက်နဲ့ ရှင်းပြပေးပါမယ်။

၁။ Call Stack ထဲမှာ တိုက်ရိုက်သိမ်းဆည်းခြင်း
Non-primitive တွေက Heap ထဲမှာ data သိမ်းပြီး Stack ထဲမှာ address ပဲသိမ်းပေမဲ့၊ 
Primitive types တွေကတော့ တကယ့် value (တန်ဖိုး) ကို 
Call Stack ထဲမှာပဲ တိုက်ရိုက် (Directly) သိမ်းပါတယ်။

ဥပမာ- let x = 10; လို့ ရေးလိုက်ရင် Stack ထဲက x ဆိုတဲ့ နေရာလေးမှာ 10 ဆိုတဲ့ တန်ဖိုးက 
တခါတည်း ရှိနေမှာပါ။ Heap ဆီ လှမ်းသွားနေဖို့ မလိုပါဘူး။

၂။ Pass by Value (တန်ဖိုးကိုသာ ကူးယူခြင်း)
ဒါက အရေးကြီးဆုံးအချက်ပါ။ Primitive variable တစ်ခုကို နောက်တစ်ခုထဲ ကူးထည့်လိုက်ရင် 
သူက လိပ်စာကို မပေးဘဲ တန်ဖိုးအစစ်ကို copy ပွား ပေးလိုက်တာပါ။

ဥပမာ-
JavaScript
let a = 50;
let b = a; // 'a' ထဲက 50 ကို copy ကူးပြီး 'b' ထဲ ထည့်လိုက်တာ

b = 100; // 'b' ကို ပြင်လိုက်ပေမဲ့

console.log(a); // 'a' က 50 ပဲ ရှိနေဆဲပါ။
ဘာကြောင့်လဲ: Stack ထဲမှာ a အတွက် နေရာတစ်ခု၊ b အတွက် နေရာတစ်ခု သီးသန့်စီ ဖြစ်သွားလို့ပါ။
 တစ်ခုကို ပြင်ရင် နောက်တစ်ခုကို လုံးဝ မထိခိုက်ပါဘူး။

၃။ Immutability (ပြောင်းလဲ၍မရခြင်း)
Primitive types တွေက Immutable ဖြစ်ပါတယ်။ ဆိုလိုတာက memory ထဲမှာရှိပြီးသား
 value တစ်ခုကို သွားပြင်လို့ မရပါဘူး။

ဥပမာ- let name = "Aung"; ဆိုပြီး သတ်မှတ်ပြီးမှ name = "Kyaw"; လို့ ပြောင်းလိုက်ရင်:

JavaScript က "Aung" ဆိုတဲ့ စာသားကို "Kyaw" ဖြစ်အောင် သွားပြင်တာ မဟုတ်ပါဘူး။

Memory (Stack) ထဲမှာ "Kyaw" ဆိုတဲ့ တန်ဖိုးအသစ်တစ်ခုကို ထပ်ဆောက်ပြီး name variable ကို
 အဲဒီတန်ဖိုးအသစ်ဆီ ပြောင်းခိုင်းလိုက်တာပါ။

အဟောင်း "Aung" ကတော့ ဘယ်သူမှ မသုံးတော့ရင် memory ထဲက ဖျက်ထုတ်ခြင်း ခံရမှာပါ။

```




## Abstract Syntax Tree (AST)
```
Abstract Syntax Tree (AST) ဆိုတာ ရိုးရိုးရှင်းရှင်း ပြောရရင် ကျနော်တို့ ရေးလိုက်တဲ့ 
Programming Code တွေကို Computer Engine (ဥပမာ- JS Engine) က နားလည်အောင်
အဆင့်ဆင့် ခွဲခြမ်းစိတ်ဖြာပြီး တည်ဆောက်လိုက်တဲ့ "သစ်ပင်ပုံစံ Structure" တစ်ခုဖြစ်ပါတယ်။

Code တွေကို စာသား (Text) အနေနဲ့ မဟုတ်ဘဲ Logical ဖြစ်တဲ့ အစိတ်အပိုင်းတွေအဖြစ် ခွဲထုတ်လိုက်တာပါ။

AST အလုပ်လုပ်ပုံ အဆင့်ဆင့်
JS Engine က Code တွေကို တိုက်ရိုက်မပတ်ဘဲ အောက်ပါအတိုင်း အဆင့်ဆင့် ပြောင်းလဲပါတယ်-

Lexical Analysis (Tokenization): ပထမဆုံး Code တွေကို const, x, =, 10 ဆိုပြီး 
အစိတ်အပိုင်း (Tokens) လေးတွေအဖြစ် အရင်ခွဲပါတယ်။

Syntax Analysis (Parsing): အဲဒီ Tokens လေးတွေကို စုစည်းပြီး တစ်ခုနဲ့တစ်ခု 
ဘယ်လိုဆက်စပ်လဲဆိုတာကို Tree ပုံစံ (AST) တည်ဆောက်ပါတယ်။

ဥပမာပြရရင်:
ကျနော်တို့က $const x = 5 + 3; လို့ ရေးလိုက်ရင် AST က ဒီလိုပုံစံမျိုး ဖြစ်သွားပါမယ်-

VariableDeclaration: const

Identifier: x

Expression: (Binary Expression)

Left: 5

Operator: +

Right: 3

AST ကို ဘာကြောင့် သုံးတာလဲ?
Engine တွေအတွက်တင်မကဘဲ ကျနော်တို့ နေ့စဉ်သုံးနေတဲ့ Tool တွေမှာလည်း AST က အရေးကြီးပါတယ်-

Minification: Code တွေထဲက မလိုအပ်တဲ့ space တွေ ဖယ်ထုတ်တာနဲ့ variable 
နာမည်တွေကို အတိုချုံ့တာ (ဥပမာ- longVariableName ကို a လို့ပြောင်းတာ) တွေမှာ သုံးပါတယ်။

Transpilation (Babel): Modern JS (ES6+) code တွေကို Browser အဟောင်းတွေမှာ
 အလုပ်လုပ်အောင် code ပြန်ပြောင်းတဲ့နေရာမှာ သုံးပါတယ်။

Linting (ESLint): ကျနော်တို့ code ရေးတာ မှားနေသလား၊ format မကျဘူးလားဆိုတာကို 
AST ကို ကြည့်ပြီး စစ်ဆေးပေးတာပါ။

အကျဉ်းချုပ်: AST ဆိုတာ Code ရဲ့ "Structure" ကို ဖော်ပြတဲ့ မြေပုံတစ်ခုဖြစ်ပြီး Engine က
 Code ကို မြန်မြန်ဆန်ဆန်နဲ့ တိတိကျကျ အကောင်အထည်ဖော်နိုင်အောင် ကူညီပေးပါတယ်။
```
--

## Interpreter နဲ့ Compiler
```
Interpreter နဲ့ Compiler က ကျွန်တော်တို့ ရေးလိုက်တဲ့ Code (High-level language) တွေကို
 စက်နားလည်တဲ့ Machine code အဖြစ် ပြောင်းလဲပေးတဲ့ ဘာသာပြန်ဆရာ (Translators) တွေ ဖြစ်ကြပါတယ်။

ဒါပေမဲ့ သူတို့ ဘာသာပြန်ပုံချင်းကတော့ လုံးဝ မတူပါဘူး။

၁။ Interpreter (တစ်ကြောင်းချင်း ဘာသာပြန်သူ)

Interpreter က ကုဒ်တွေကို တစ်ကြောင်းချင်းစီ ဖတ်တယ်၊ တစ်ခါတည်း ဘာသာပြန်တယ်၊ တစ်ခါတည်း Run ပါ တယ်။

ဘယ်လိုအလုပ်လုပ်လဲ: ပထမစာကြောင်းကို ဖတ်တယ်၊ အမှားမရှိရင် Run တယ်။ ပြီးမှ ဒုတိယစာကြောင်းကို ဆက်ဖတ်တယ်။

အားသာချက်: အမှားရှာရလွယ်ကူတယ် (Debugging)။ ကုဒ်ကို ပြင်ပြီးတာနဲ့ တန်း Run လို့ရတယ်။

အားနည်းချက်: ကုဒ်တစ်ခုလုံး ပြီးအောင် Run ဖို့အတွက် ကြာချိန် ပိုပေးရတတ်တယ် (Run တိုင်း အမြဲပြန်ဖတ်နေရလို့)။

ဥပမာ: Python, Ruby, PHP (Original JavaScript)။

၂။ Compiler (တစ်အုပ်လုံး ကြိုတင်ဘာသာပြန်သူ)

Compiler ကတော့ ကုဒ်တစ်ခုလုံး (Project တစ်ခုလုံး) ကို အရင်ဆုံး အစကနေ အဆုံး ဖတ်လိုက်ပါတယ်။
 ပြီးမှ စက်နားလည်တဲ့ ဖိုင်အသစ် (ဥပမာ .exe ဖိုင်) တစ်ခုအဖြစ် တစ်ခါတည်း ပြောင်းပစ်လိုက်တာပါ။

ဘယ်လိုအလုပ်လုပ်လဲ: ကုဒ်တစ်ခုလုံးကို အရင် စစ်ဆေးတယ် (Compile လုပ်တယ်)။
 အမှားလုံးဝမရှိမှသာ Machine code ထွက်လာပါတယ်။ အဲဒီထွက်လာတဲ့ဖိုင်ကိုမှ Run ရတာပါ။

အားသာချက်: Execution Speed အရမ်းမြန်တယ်။ ကုဒ်ကို တစ်ခါပဲ ဘာသာပြန်ထားဖို့ လိုပြီး နောက်ပိုင်း ထပ်ခါတလဲလဲ Run ရုံပဲ။

အားနည်းချက်: ကုဒ်အနည်းငယ်ပြင်ရင်တောင် တစ်ခါပြန် Compile လုပ်ရပါတယ်။

ဥပမာ: C, C++, Rust, Go, Java။
```
---
# UML

```
Unified Modeling Language (UML) ဆိုတာ ဆော့ဖ်ဝဲလ်စနစ်တစ်ခုရဲ့ တည်ဆောက်ပုံ၊ အလုပ်လုပ်ပုံနဲ့ အစိတ်အပိုင်းတွေကြား
ချိတ်ဆက်မှုကို Visual (ရုပ်ပုံ) အနေနဲ့ ဖော်ပြတဲ့ စံနှုန်းသတ်မှတ်ထားတဲ့ ဘာသာစကားတစ်ခု ဖြစ်ပါတယ်။

အလွယ်ပြောရရင် အင်ဂျင်နီယာတွေ အိမ်မဆောက်ခင် ဆွဲရတဲ့ "(Blueprints)" နဲ့ တူပါတယ်။ Code တွေ အများကြီး
မရေးခင်မှာ ဆော့ဖ်ဝဲလ်က ဘယ်လို အလုပ်လုပ်မှာလဲဆိုတာကို ပုံနဲ့ အရင်ပြတာပါ။

၁။ UML က ဘာကြောင့် အရေးကြီးတာလဲ?
Communication: Developer တွေ၊ Designer တွေနဲ့ လုပ်ငန်းရှင်တွေကြားမှာ စနစ်တစ်ခုအကြောင်းကို စကားနဲ့ပြောမယ့်အစား ပုံနဲ့ပြပြီး
နားလည်မှု ညှိနှိုင်းနိုင်ပါတယ်။

Planning: Code မရေးခင်မှာ အမှားတွေကို ကြိုမြင်နိုင်ပါတယ်။

Documentation: ဆော့ဖ်ဝဲလ်တစ်ခုကို နောက်ပိုင်းမှာ ပြန်ပြင်ချင်တဲ့အခါ အရင်က ဘယ်လိုဆောက်ထားလဲဆိုတာကို
 UML ကြည့်ပြီး အလွယ်တကူ သိနိုင်ပါတယ်။

၂။ အသုံးအများဆုံး UML Diagram အမျိုးအစားများ

UML မှာ ပုံစံပေါင်း ၁၄ မျိုးခန့် ရှိပေမယ့် Software Engineering မှာ အဓိက သုံးလေ့ရှိတာတွေကတော့-

(က) Use Case Diagram (အသုံးပြုသူနှင့် စနစ်၏ ပတ်သက်မှု)
ဒီ diagram က "ဘယ်သူက ဘာလုပ်နိုင်လဲ?" ဆိုတာကို ပြပါတယ်။ ဥပမာ - ATM စက်တစ်ခုမှာဆိုရင် Customer က ပိုက်ဆံထုတ်မယ်၊
Bank Staff က ပိုက်ဆံဖြည့်မယ် ဆိုတာမျိုးကို ပြတာပါ။

(ခ) Class Diagram (စနစ်၏ တည်ဆောက်ပုံ)
ဒါကတော့ System Architecture အတွက် အရေးကြီးဆုံးပါ။ ဆော့ဖ်ဝဲလ်ထဲမှာပါမယ့် Object တွေ၊ Class တွေနဲ့ သူတို့ကြားက ဆက်သွယ်ချက်တွေကို ပြပါတယ်။
 ဥပမာ - 'User' ဆိုတဲ့ Class နဲ့ 'Account' ဆိုတဲ့ Class ဘယ်လို ချိတ်ဆက်နေလဲ ဆိုတာမျိုးပါ။

(ဂ) Sequence Diagram (အလုပ်လုပ်ပုံ အဆင့်ဆင့်)
ဒါကတော့ စနစ်ထဲက အစိတ်အပိုင်းတွေ တစ်ခုနဲ့တစ်ခု ဘယ်လို အချိန်ကိုက် အလုပ်လုပ်ကြလဲ (Message ပို့ကြလဲ) ဆိုတာကို အစဉ်လိုက် ပြတာပါ။
ဥပမာ - User က Login နှိပ်လိုက်ရင် Server ဆီ ဘယ်လိုသွားတယ်၊ Database က ဘယ်လို ပြန်ဖြေတယ် ဆိုတာမျိုးပါ။

၃။ UML နဲ့ System Architect ဘယ်လို ဆက်စပ်သလဲ?

 System Architect မှာ UML က မရှိမဖြစ်ပါ။ စနစ်ကြီးတစ်ခုလုံးကို Design ဆွဲတဲ့အခါ:

High-level view အတွက် Use Case Diagrams တွေကို သုံးပါတယ်။

Database နဲ့ Code logic အတွက် Class Diagrams တွေကို သုံးပါတယ်။

Data Flow တွေအတွက် Sequence Diagrams တွေကို သုံးပါတယ်။

အနှစ်ချုပ်

UML ဆိုတာ code မဟုတ်ပါဘူး၊ code မရေးခင် ဆွဲရတဲ့ ဒီဇိုင်းပုံကြမ်း ဖြစ်ပါတယ်။
```
---
# Use Case Diagram

* Use Case Diagram ဆိုတာ စနစ်တစ်ခု (System) နဲ့ အဲဒီစနစ်ကို အသုံးပြုမယ့်သူ (Users/Actors) ကြားက
ဆက်သွယ်ဆောင်ရွက်ချက်တွေကို ရုပ်ပုံနဲ့ ဖော်ပြတာ ဖြစ်ပါတယ်။

ဒါဟာ "ဒီ System က ဘာတွေလုပ်ပေးနိုင်လဲ?" ဆိုတဲ့ မေးခွန်းကို အဖြေထုတ်ပေးတဲ့  (Blueprint) တစ်ခုပါပဲ။

၁။ Use Case Diagram မှာပါဝင်တဲ့ အဓိက အစိတ်အပိုင်း (၄) ခု

Use Case တစ်ခုကို ဆွဲတော့မယ်ဆိုရင် အောက်ပါ သင်္ကေတလေးတွေကို သိထားဖို့ လိုပါတယ်။

* Actor (အသုံးပြုသူ): စနစ်ရဲ့ အပြင်ဘက်ကနေ စနစ်နဲ့ ဆက်သွယ်မယ့်သူ (သို့မဟုတ် အခြားစနစ်တစ်ခု)။
သူ့ကို လူရုပ်ပုံ (Stick Figure) လေးနဲ့ ကိုယ်စားပြုပါတယ်။

* Use Case (လုပ်ဆောင်ချက်): စနစ်က လုပ်ပေးနိုင်တဲ့ Function တစ်ခုခု။ သူ့ကို အဝိုင်းပုံ (Oval) လေးနဲ့ ပြပါတယ်။ 
(ဥပမာ - Login ဝင်ခြင်း၊ ပိုက်ဆံထုတ်ခြင်း)။

* System Boundary (စနစ်၏ ဘောင်): စနစ်ရဲ့ အတိုင်းအတာကို ပြတဲ့ လေးထောင့်ကွက် (Rectangle) ဖြစ်ပါတယ်။
Use Case တွေအားလုံးဟာ ဒီသေတ္တာထဲမှာ ရှိနေရပါမယ်။

* Association (ဆက်သွယ်မှု): Actor နဲ့ Use Case ကြား ချိတ်ဆက်ထားတဲ့ မျဉ်းကြောင်း ဖြစ်ပါတယ်။


UML မှာ ပိုပြီး တိကျအောင် အောက်ပါ (၂) မျိုးကို သုံးလေ့ရှိပါတယ်။

* <<Include>> (မဖြစ်မနေ ပါဝင်ရမည်): Use Case တစ်ခု အလုပ်လုပ်ဖို့ နောက်တစ်ခုက မရှိမနေ လိုအပ်တာမျိုးပါ။
ဥပမာ - Check Balance လုပ်ဖို့ဆိုရင် Login အရင်ဝင်ဖို့ လိုအပ်တဲ့အတွက် Check Balance က Login ကို Include လုပ်ထားရပါတယ်။

* <<Extend>> (ရွေးချယ်ခွင့်ရှိသည်): အခြေအနေတစ်ခုပေါ် မူတည်ပြီးမှ အပိုဆောင်း လုပ်ဆောင်တာမျိုးပါ။
ဥပမာ - Withdraw Cash လုပ်ပြီးတဲ့အခါ "ပြေစာထုတ်မလား" လို့ မေးတာမျိုးပါ။ Print Receipt က Withdraw ရဲ့ Extend လုပ်ဆောင်ချက် ဖြစ်ပါတယ်။
