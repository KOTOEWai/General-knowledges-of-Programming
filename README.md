
## 📑 Table of Contents

- [Vite](#Vite)
- [Bundler](#Bundler)
- [Call Stack နှင့် Memory Heap အလုပ်လုပ်ပုံ](#Call-Stack-နှင့်-Memory-Heap-အလုပ်လုပ်ပုံ)



## Vite

```
Vite (ပြင်သစ်ဘာသာစကားဖြင့် "အမြန်" ဟု အဓိပ္ပာယ်ရပြီး "veet" ဟု အသံထွက်သည်) သည် ခေတ်သစ် Web Development လောကတွင် အသုံးပြုနေကြသည့်
အလွန်မြန်ဆန်သော Build Tool တစ်ခု ဖြစ်ပါသည်။

အရင်က React project တွေမှာ အသုံးများခဲ့တဲ့ Create React App (CRA) နဲ့ Webpack တို့နေရာမှာ အခုဆိုရင် Vite က အစားထိုးဝင်ရောက်လာပြီ ဖြစ်ပါတယ်။

Vite က ဘာကြောင့် ပိုကောင်းတာလဲ?

Vite ကို အဓိက အချက် (၂) ချက်ကြောင့် လူကြိုက်များကြပါတယ်-

1. အလွန်မြန်သော Development Server: သင် code တစ်ခုခုပြင်လိုက်တိုင်း Browser မှာ ချက်ချင်းပြောင်းလဲသွားအောင် လုပ်ဆောင်ပေးတဲ့နေရာမှာ
 Webpack ထက် အဆပေါင်းများစွာ ပိုမြန်ပါတယ်။ ဒါကို Hot Module Replacement (HMR) လို့ ခေါ်ပါတယ်။

2. မြန်ဆန်သော Build Time: Project ကို အချောသတ် (Production) ထုတ်တဲ့အခါမှာလည်း ခေတ်မီတဲ့ Rollup bundler ကို အသုံးပြုထားလို့ 
file size သေးသေးနဲ့ မြန်မြန်ဆန်ဆန် ထွက်လာစေပါတယ်။

Vite ရဲ့ အဓိက ထူးခြားချက်များ

Instant Server Start: Project ကို စတင် run တဲ့အခါ စက္ကန့်ပိုင်းအတွင်း တက်လာပါတယ်။

TypeScript Ready: TypeScript အတွက် ဘာမှထပ်ပြင်စရာမလိုဘဲ အသင့်အသုံးပြုနိုင်ပါတယ်။

Optimized Build: သင့်ရဲ့ Website ကို အမြန်ဆုံး load ဖြစ်အောင် code တွေကို အလိုအလျောက် ကျစ်လျစ်အောင် လုပ်ပေးပါတယ်။

Plugin Ecosystem: လိုအပ်တဲ့ features တွေကို plugin တွေအဖြစ် အလွယ်တကူ ထည့်သွင်းနိုင်ပါတယ်။

မှတ်ချက်: အခုနောက်ပိုင်း React ရော၊ Vue ရော၊ အခြား Frontend Framework တွေမှာပါ Vite ကိုပဲ Standard အနေနဲ့ သုံးဖို့ အကြံပြုထားကြပါတယ်။
```


## Bundler
```
Bundler ဆိုတာ သင့်ရဲ့ Web Project မှာရှိတဲ့ ရာနဲ့ချီတဲ့ JavaScript file တွေ၊ CSS တွေနဲ့ ပုံ (Images) တွေကို
စုစည်းပြီး Browser က ဖတ်လို့ရမယ့် File အနည်းငယ် (ဥပမာ- bundle.js) ဖြစ်အောင် ပေါင်းစည်းပေးတဲ့ 
ကိရိယာ (Tool) တစ်ခုဖြစ်ပါတယ်။

* လွယ်လွယ်ပြောရရင်တော့ ဟင်းချက်တဲ့အခါ လိုအပ်တဲ့ ပါဝင်ပစ္စည်းတွေကို အိတ်တစ်အိတ်ထဲ စနစ်တကျ ထည့်ပေးလိုက်သလိုပါပဲ။

Bundler က ဘာကြောင့် လိုအပ်တာလဲ?

 ၁။ File တွေ အရမ်းများခြင်း: Developer တွေက အလုပ်လုပ်ရလွယ်အောင် code တွေကို file သေးသေးလေးတွေ အများကြီး ခွဲရေးကြပါတယ်။
  ဒါပေမဲ့ Browser က အဲဒီ file ပေါင်းများစွာကို တစ်ခုချင်းစီ လှမ်းခေါ်နေရင် Website က အရမ်းနှေးသွားပါလိမ့်မယ်။

 ၂။ Dependency Management: File တစ်ခုနဲ့တစ်ခု ချိတ်ဆက်နေမှု (ဥပမာ- A က B ကို အားကိုးနေတာမျိုး) ကို Bundler က စနစ်တကျ စီစဉ်ပေးပါတယ်။
 
 ၃။ Asset Optimization: Code တွေကို ကျစ်လျစ်အောင်လုပ်တာ (Minification) နဲ့ မလိုအပ်တဲ့ code တွေကို ဖယ်ထုတ်တာ (Tree Shaking) တွေကို လုပ်ဆောင်ပေးပါတယ်။

Bundler တစ်ခု ဘယ်လိုအလုပ်လုပ်သလဲ?

Bundler က သင့်ရဲ့ Project ထဲက အဓိက file (Entry Point) ကို အရင်ကြည့်ပါတယ်။ အဲဒီကမှတစ်ဆင့် ချိတ်ဆက်နေတဲ့ အခြား file တွေကို လိုက်ရှာပြီး "Graph" တစ်ခု ဆောက်ပါတယ်။ နောက်ဆုံးမှာတော့ Browser နားလည်တဲ့ static file တွေအဖြစ် ပြောင်းလဲပေးလိုက်ပါတယ်။

သင်က Vite ကို သုံးနေတယ်ဆိုရင် Bundler အကြောင်းကို ခေါင်းထဲအများကြီး ထည့်စရာမလိုဘဲ သူက အနောက်ကနေ အကုန်လုံးကို အလိုအလျောက် အကောင်းဆုံးဖြစ်အောင် စီစဉ်ပေးသွားမှာပါ။
```
## Call Stack နှင့် Memory Heap အလုပ်လုပ်ပုံ

```
Reference types (Objects, Arrays) တွေအတွက် JavaScript က အခုလို ခွဲဝေလိုက်ပါတယ်-

Memory Heap
    တကယ့် Data အကြီးစားတွေ (ဥပမာ- { name: "Aung Aung", age: 25 }) ကို ဒီနေရာမှာ သိမ်းပါတယ်။
ဒီနေရာက ကျယ်ဝန်းပြီး ရှုပ်ထွေးတဲ့ structure တွေကို သိမ်းဖို့ပါ။

Call Stack
    ဒီနေရာမှာတော့ variable နာမည်နဲ့ အဲဒီ data ရှိရာနေရာကို ညွှန်ပြတဲ့ Memory Address (Reference) ကိုပဲ သိမ်းပါတယ်။


ဘယ်လို အလုပ်လုပ်သလဲ (Step-by-Step)

ဥပမာ- let user = { name: "Aung Aung" }; လို့ ရေးလိုက်ရင်:

အဆင့် (၁): JavaScript က Heap ထဲမှာ နေရာလွတ်တစ်ခုရှာပြီး { name: "Aung Aung" } ဆိုတဲ့ object ကို သိမ်းလိုက်ပါတယ်။
 အဲဒီနေရာရဲ့ လိပ်စာက ဥပမာ 0x123 ဆိုပါစို့။

အဆင့် (၂): Call Stack ထဲမှာ user ဆိုတဲ့ variable name ကို သတ်မှတ်ပါတယ်။

အဆင့် (၃): Stack ထဲက user ရဲ့ value နေရာမှာ အစောက လိပ်စာ 0x123 ကို သိမ်းလိုက်ပါတယ်။

မှတ်ချက်: Stack ထဲမှာ object ကြီးတစ်ခုလုံး သိမ်းဖို့က နေရာမလောက်နိုင်သလို၊ ရှုပ်ထွေးနိုင်တာကြောင့် လိပ်စာကတ်လေး (Reference) ကိုပဲ Stack ထဲ ထည့်ထားတာ ဖြစ်ပါတယ်။


Location,        Identifier (Variable)            Value (Content)

Call Stack,          user,                           Ref: 0x123 (Address)
Memory Heap          0x123,                         { name: ""Aung Aung"" }


ဒါကြောင့် ဘာဖြစ်သလဲ?
သင်က let admin = user; လို့ ထပ်ရေးလိုက်ရင် JavaScript က Stack ထဲမှာ variable အသစ်တစ်ခု ဆောက်ပါတယ်။ ဒါပေမဲ့ သူက value အသစ်ကို copy ကူးတာ မဟုတ်ဘဲ 0x123 ဆိုတဲ့ လိပ်စာကိုပဲ copy ကူးလိုက်တာပါ။

ရလဒ်ကတော့ user ရော admin ရောက Heap ထဲက object တစ်ခုတည်းကိုပဲ ပိုင်ဆိုင်သွားတာ ဖြစ်ပါတယ်။



```
